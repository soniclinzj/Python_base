# 2.4 切片
''''''
'''
s[a:b:c]  对s在a和b之间以c为间隔取值，包含a,但不包含b
格式：seq[start:stop:step]

为什么切片和区间会忽略最后一个元素（b），python与c和其它语言里都以0作为起始下标的传统这样的好处：
    . 当只有最后一个位置信息时，可以快速看出切片和区间里有几个元素：range(3) 和 my_list[:3]都返回3个元素
    . 当起止位置信息都可见时，可以快速计算出切片和区间的长度，用后一个数减去第一个下标（stop-start）即可
    . 这样做也可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成my_list[:x]和my_list[x:]就可以了。

        # 1 步长为3的方式进行取值[0，0+3，0+3+3]=[0,3,6]
        # 2 反向排序
        # 3 先倒序,再针对倒序的结果进行步长为2的方式取值

'''

print('\n2.4.2', '=' * 20)

s = 'bicycles'
b = s[::3]  # 1
print(b)

c = s[::-1]  # 2
print(c)

d = s[::-2]  # 3
print(d)

'''
# 2.4.3 多维切片和省略
    多维切片：外部库NumPy里就用到了这个特征 a[m:n,k:l]的方式获取二维切片
        # 4 Python 内置的序列类型都是一维的，因此它只支持单一的索引即成对的索引是没有用的。
            处理方式就是每产出一维的再将取得的值进行再排列
    省略：ellipsis 正确的书写方法是三个英语句号（...）,而不是Unicode 码位U+2026中表示的半个省略号
        如果x是个四维数组那么x[i,...] 就是 x[i,:,:,:]的缩写
'''

e = s[:3] + s[5:]  # 4
print(e)

'''
2.4.4 给切片赋值
把切片放在赋值语句的左边，或把它作为 del操作的对象，就可以对序列进行嫁接、切除或就地修改操作

        # 1 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        # 2 [0, 1, 20, 30, 5, 6, 7, 8, 9] ，将[2:5]的数据 2，3，4 替换成[20,30]
        # 3 [0, 1, 20, 30, 5, 8, 9]，删除[5:7]的数据6，7
        # 4 [0, 1, 20, 11, 5, 22, 9],从位置3开始到结束，依步长2的方式进行替换，分别对应11与22
            （如步长内还有数据要替换，而替换数据量不足时会提示错误）
        # 5 [0, 1, 100, 22, 9]，将[2:5]的数据替换成100同#2，
            如赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也可把它转换成可迭代的序列。

'''

print('\n2.4.4', '=' * 20)

l = list(range(10))
print(l)  # 1

l[2:5] = [20, 30]  # 2
print(l)

del l[5:7]  # 3
print(l)

l[3::2] = [11, 22]  # 4
print(l)

l[2:5] = [100]  # 5
print(l)


'''
2.5 对序列使用+和*
    通常+号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，
    Python会新建一个包含同样类型数据的序列来作为拼接的结果
    +和*都是遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列

    #1 建立一个包含3个列表的列表（分别创建），被包含的3个列表有各自的3个元素。
    #2 把编号为1的列表中的编号为2的个元系替换成x

    #3 把[['_']*3]复制3份列表，每个列表都指向同一地址
    #4 把编号为1的列表中的编号为2的个元系替换成x，就会呈现出3个引用指向同一个对象的事实



建立由列表组成的列表
'''
print('\n2.5', '=' * 20)
l = [1, 2, 3, 'a']
l = l * 5
print(l)


board = [['_'] * 3 for i in range(3)]  # 1
print(board)

board[1][2] = 'x'  # 2
print(board)

weird_board = [['_'] * 3] * 3  # 3
print(weird_board)
weird_board[1][2] = 'x'  # 4
print(weird_board)

'''
# 2.6 序列的增量赋值
增量赋值运算符 += 和 *= 的表现取决于它们的第一个操作对象。简单起见，我们把讨论
集中在增量加法（+=）上，但是这些概念对 *= 和其他增量运算符来说都是一样的。
    #1 刚开始时列表的 ID。
    #2 运用增量乘法后，列表的 ID 没变，新元素追加到列表上。
    #3 元组最开始的 ID。
    #4 运用增量乘法后，新的元组被创建。
        对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，
        而解释器需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。
        *   不要把可变对象放在元组里面。
'''
print('\n2.6', '=' * 20)

l = [1, 2, 3]
print(id(l))  # 1

l *= 2
print(l)
print(id(l))  # 2

t = (1, 2, 3)
print(id(t))  # 3
t *= 2
print(t)
print(id(t))  # 4


'''
# 2.7 list.sort方法和内置函数sorted
        list.sort 方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的返回值是 None 的原因，
        提醒你本方法不会新建一个列表。在这种情况下返回 None---将原列表排序打乱变更
        其实是 Python 的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 None，好让调用
        者知道传入的参数发生了变动，而且并未产生新的对象

        与 list.sort 相反的是内置函数 sorted，它会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代
        对象作为参数，甚至包括不可变序列或生成器（见第 14 章）。而不管 sorted 接受的是怎样的参数，它最后都
        会返回一个列表。---不会改变原来的列表内的排序

        不管是 list.sort 方法还是 sorted 函数，都有两个可选的关键字参数。
            reverse:
        　　如果被设定为 True，被排序的序列里的元素会以降序输出（也就是说把最大值当作最小值来排序）。
            这个参数的默认值是 False。
            key:
            一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。
            比如说，在对一些字符串排序时，可以用 key=str.lower 来实现忽略大小写的排序，或者是用 key=len 进行基
            于字符串长度的排序。这个参数的默认值是恒等函数（identity function），也就是默认用元素自己的值来排序。
                    ❶ 新建了一个按照字母排序的字符串列表。
                    ❷ 原列表并没有变化。
                    ❸ 按照字母降序排序。
                    ❹ 新建一个按照长度排序的字符串列表。因为这个排序算法是稳定
                    的，grape 和 apple 的长度都是 5，它们的相对位置跟在原来的列表里是
                    一样的。
                    ❺ 按照长度降序排序的结果。结果并不是上面那个结果的完全翻转，
                    因为用到的排序算法是稳定的，也就是说在长度一样时，grape 和 apple
                    的相对位置不会改变。
                    ❻ 直到这一步，原列表 fruits 都没有任何变化。
                    ❼ 对原列表就地排序，返回值 None 会被控制台忽略。
                    ❽ 此时 fruits 本身被排序。

'''
print('\n2.7', '=' * 20)
fruits = ['grape', 'raspberry', 'apple', 'banana']
print("fruits = ['grape', 'raspberry', 'apple', 'banana']")
print('fruits id=', id(fruits))
print('#1', sorted(fruits))  # 1
print('#2', fruits)  # 2

print('#3', sorted(fruits, reverse=True))  # 3

print('#4', sorted(fruits, key=len))  # 4

print('#5', sorted(fruits, key=len, reverse=True))  # 5

print('#6', fruits)  # 6

print('fruits id=', id(fruits))

print('#7', fruits.sort())  # 7
print('#8', fruits)  # 8
print('fruits id=', id(fruits))
